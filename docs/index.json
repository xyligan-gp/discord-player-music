{
 "meta": {
  "generator": "0.11.1",
  "format": 22,
  "date": 1687617980752
 },
 "custom": {
  "general": {
   "name": "General",
   "files": {
    "welcome": {
     "name": "Welcome",
     "type": "md",
     "content": "<div align=\"center\">\r\n\t<h1>Welcome to the 'discord-player-music' page!</h1>\r\n\t<br />\r\n\t<p>\r\n\t\t<a href=\"https://dpm.js.org\"><img src=\"https://i.imgur.com/4Pk9WlS.gif\" width=\"546\" alt=\"DPM Main Image\" /></a>\r\n\t</p>\r\n\t<br/>\r\n\t<p>\r\n\t\t<a href=\"https://discord.gg/zzbkvCcu2r\"><img src=\"https://img.shields.io/discord/827221018879328298?color=5865F2&logo=discord&logoColor=white\" alt=\"Support Server\" /></a>\r\n\t\t<a href=\"https://www.npmjs.com/package/discord-player-music\"><img src=\"https://img.shields.io/npm/dt/discord-player-music.png?maxAge=3600\" alt=\"NPM downloads\" /></a>\r\n\t\t<a href=\"https://www.npmjs.com/package/discord-player-music\"><img src=\"https://img.shields.io/npm/v/discord-player-music.png?maxAge=3600\" alt=\"NPM page\" /></a>\r\n\t</p>\r\n</div>\r\n\r\n## About\r\n\r\n**Discord Player Music is a powerful [Node.js](https://nodejs.org) music module for your Discord.js bot that based on Promises and has a lot of features.**\r\n\r\n* ðŸ‘ Simple & easy to use\r\n* ðŸ˜„ Beginner friendly\r\n* ðŸŽ¸ Audio filters\r\n* ðŸ“ƒ Lyrics\r\n* ðŸ“‚ Multiple servers\r\n\r\n## Installation\r\n\r\n**Node.js 16.9.0 or newer is required.**\r\n\r\n```sh-session\r\n$ npm install discord-player-music\r\n$ yarn add discord-player-music\r\n$ pnpm add discord-player-music\r\n```\r\n\r\n## Example Usage\r\n\r\n```js\r\nconst { Client, GatewayIntentBits, Partials } = require('discord.js');\r\nconst { Player } = require('discord-player-music');\r\n\r\nconst client = new Client({\r\n\tintents: [\r\n\t\tGatewayIntentBits.Guilds,\r\n\t\tGatewayIntentBits.MessageContent,\r\n\t\tGatewayIntentBits.GuildMembers,\r\n\t\tGatewayIntentBits.GuildMessages,\r\n\t\tGatewayIntentBits.GuildMessageReactions,\r\n\t\tGatewayIntentBits.GuildVoiceStates\r\n\t],\r\n    \r\n\tpartials: [\r\n\t\tPartials.Channel,\r\n\t\tPartials.GuildMember,\r\n\t\tPartials.Message,\r\n\t\tPartials.Reaction,\r\n\t\tPartials.User\r\n\t]\r\n});\r\n\r\nclient.player = new Player(client);\r\n\r\nclient.on('ready', async () => {\r\n  \treturn console.log('Client is ready!');\r\n})\r\n\r\nclient.player.on('ready', async () => {\r\n\treturn console.log('Player is ready!');\r\n})\r\n\r\nclient.login('YOUR_CLIENT_TOKEN_HERE');\r\n```\r\n\r\n## Links\r\n\r\n* NPM: [Open](https://www.npmjs.com/package/discord-player-music)\r\n* GitHub: [Open](https://github.com/xyligan-gp/discord-player-music)\r\n* Examples: [See](https://github.com/xyligan-gp/discord-player-music/tree/stable/examples)\r\n* Documentation: [Open](https://dpm.js.org)\r\n\r\n* Module Developer: [xyligan](https://github.com/xyligan-gp)\r\n* Developer Discord: [â™¡ xÒ¯â„“[Î¹]gÎ±Î·4Îµg â™¡#9457](https://discord.com/users/533347075463577640)\r\n* Support Server: [Join xyligan development](https://discord.gg/zzbkvCcu2r)\r\n\r\n<center><h1>â™¥ Thanks for using Discord Player Music â™¥</h1></center>",
     "path": "docs/general/welcome.md"
    },
    "faq": {
     "name": "FAQ",
     "type": "md",
     "content": "# Frequently Asked Questions\r\n\r\nThese questions are some of the most frequently asked.\r\n\r\n## How do I get voice working?\r\n* Install `@discordjs/opus` | Command: `npm install @discordjs/opus`\r\n* Install `@discordjs/voice` | Command: `npm install @discordjs/voice`\r\n\r\n## Why am I getting Status code: 403 error?\r\nThe `Status code: 403` error occurs when there are minor problems with the YouTu be API, but don't worry, if you receive an error, the module will automatically make several retry attempts to play the song. If this fails, you can notify the server users about it and contact the module support server for help.\r\n\r\n## Why am I getting Status code: 404 error?\r\nThe `Status code: 404` error occurs when there are critical problems in the YouTu be API, but do not worry, when you receive an error, the module will automatically notify you about this with an error in the console.\r\n\r\n## Why does the bot sometimes just crash?\r\nIf while trying to play a song your bot received an error and crashed, we recommend that you review the error received and do everything possible to fix it. If all else fails, contact the module support server.",
     "path": "docs/general/faq.md"
    },
    "updating": {
     "name": "Updating your code",
     "type": "md",
     "content": "# Updating page\r\n\r\nThis documentation page is a short list of changes to your code that will have to be done when switching to a specific version of discord-player-music!\r\n\r\n## 1.1.5\r\nIn version 1.1.5, `discord-player-music` was completely rewritten for the manager system.\r\n\r\n### Player Constructor\r\n\r\n```diff\r\n+ options.searchResultsLimit\r\n+ options.synchronLoop\r\n+ options.defaultVolume\r\n\r\n+ options.collectorsConfig.autoAddingSongs\r\n+ options.collectorsConfig.maxAttempts\r\n+ options.collectorsConfig.time\r\n```\r\n\r\n### Player Methods Update\r\n#### CollectorsManager\r\n\r\n```diff\r\n+ player.collectors.message\r\n```\r\n\r\n#### VoiceManager\r\n\r\n```diff\r\n- player.joinVoiceChannel\r\n+ player.voice.join\r\n\r\n- player.leaveVoiceChannel\r\n+ player.voice.leave\r\n```\r\n\r\n#### UtilsManager\r\n\r\n```diff\r\n- player.createStream\r\n+ player.utils.checkNode\r\n+ player.utils.checkOptions\r\n+ player.utils.checkPermissions\r\n+ player.utils.createCollector\r\n```\r\n\r\n#### Main Player\r\n\r\n```diff\r\n- player.getSongIndex\r\n\r\n- player.skipSong\r\n+ player.skip\r\n\r\n- player.stopPlaying\r\n+ player.stop\r\n\r\n- player.pausePlaying\r\n+ player.pause\r\n\r\n- player.resumePlaying\r\n+ player.resume\r\n\r\n- player.getCurrentSongInfo\r\n+ player.getSongInfo\r\n\r\n- player.initPlayer\r\n+ player.init\r\n```\r\n\r\n## 1.1.7\r\nIn version 1.1.7, `discord-player-music` was completely rewritten on TypeScript language.\r\n\r\n### Module Constructor\r\n\r\n```diff\r\n- options.collectorsConfig.autoAddingSongs\r\n- options.collectorsConfig.maxAttempts\r\n- options.collectorsConfig.time\r\n+ options.autoAddingTracks\r\n\r\n+ options.databaseConfig\r\n+ options.databaseConfig.path\r\n+ options.databaseConfig.checkInterval\r\n\r\n+ options.progressConfig\r\n+ options.progressConfig.size\r\n+ options.progressConfig.line\r\n+ options.progressConfig.slider\r\n\r\n+ options.collectorsConfig.message\r\n+ options.collectorsConfig.message.time\r\n+ options.collectorsConfig.message.attempts\r\n\r\n+ options.collectorsConfig.reaction\r\n+ options.collectorsConfig.reaction.time\r\n+ options.collectorsConfig.reaction.attempts\r\n+ options.collectorsConfig.reaction.reactions\r\n```\r\n\r\n### Player Events Update\r\n\r\n```diff\r\n+ player#ready\r\n+ player#queueStarted\r\n+ player#createdPlaylist\r\n+ player#deletedPlaylist\r\n+ player#queueStateChange\r\n\r\n- player#playerError\r\n+ player#error\r\n\r\n- player#songsAdded\r\n+ player#addedTrack\r\n\r\n- player#playingSong\r\n+ player#playingTrack\r\n```\r\n\r\n### Player Methods Update\r\n\r\n#### Main Player Class\r\n\r\n```diff\r\n- player.collectors.message\r\n+ player.createCollector\r\n\r\n- player.play\r\n+ player.initGuildTrack\r\n\r\n- player.searchSong\r\n+ player.search\r\n\r\n- player.addSong\r\n+ player.initQueueTrack\r\n\r\n- player.pause\r\n- player.resume\r\n+ player.queue.setState\r\n\r\n- player.setLoopSong\r\n- player.setLoopQeue\r\n+ player.queue.setLoop\r\n\r\n- player.skip\r\n+ player.queue.skipTrack\r\n\r\n- player.setFilter\r\n+ player.queue.setFilter\r\n\r\n- player.shuffle\r\n+ player.queue.shuffle\r\n\r\n- player.getGuildMap\r\n- player.getQueue\r\n+ player.queue.get\r\n\r\n- player.getSongInfo\r\n+ player.queue.trackInfo\r\n+ player.queue.streamInfo\r\n\r\n- player.getLyrics\r\n+ player.lyrics\r\n\r\n- player.getFilters\r\n+ player.filters.list\r\n\r\n- player.createProgressBar\r\n+ player.queue.progress\r\n\r\n- player.setVolume\r\n+ player.queue.setVolume\r\n\r\n- player.stop\r\n+ player.queue.stop\r\n\r\n- player.removeSong\r\n+ player.queue.removeTrack\r\n```\r\n\r\n#### DatabaseManager\r\n\r\n```diff\r\n+ player.database.get\r\n+ player.database.write\r\n+ player.database.initGuild\r\n+ private player.database.init\r\n```\r\n\r\n#### FiltersManager\r\n\r\n```diff\r\n+ player.filters.add\r\n+ player.filters.isExists\r\n+ player.filters.get\r\n+ player.filters.list\r\n+ player.filters.delete\r\n+ private player.filters.init\r\n```\r\n\r\n#### PlaylistsManager\r\n\r\n```diff\r\n+ player.playlists.create\r\n+ player.playlists.addTrack\r\n+ player.playlists.play\r\n+ player.playlists.removeTrack\r\n+ player.playlists.delete\r\n```\r\n\r\n#### QueueManager\r\n\r\n```diff\r\n+ player.queue.add\r\n+ player.queue.get\r\n+ player.queue.progress\r\n+ player.queue.streamInfo\r\n+ player.queue.trackInfo\r\n+ player.queue.setFilter\r\n+ player.queue.setLoop\r\n+ player.queue.setState\r\n+ player.queue.setVolume\r\n+ player.queue.skipTrack\r\n+ player.queue.removeTrack\r\n+ player.queue.seek\r\n+ player.queue.shuffle\r\n+ player.queue.stop\r\n+ player.queue.delete\r\n```\r\n\r\n#### UtilsManager\r\n\r\n```diff\r\n- player.utils.checkNode\r\n- player.utils.checkPermissions\r\n- player.utils.getPlayerMode\r\n+ player.utils.formatDuration\r\n+ player.utils.createEmptyProgress\r\n+ player.utils.getUniqueID\r\n+ player.utils.getTrackDuration\r\n```",
     "path": "docs/general/updating.md"
    },
    "index": {
     "name": "Examples",
     "type": "md",
     "content": "# A small example of writing a music bot using module\r\n\r\nThis is just the smallest part of what can be done. More examples can be found here: **[discord-player-music/examples](https://github.com/xyligan-gp/discord-player-music/tree/stable/examples)**\r\n\r\n## Client and module initialization\r\n\r\n```js\r\nimport { Collector, GuildQueueState, Loop, Player, Search } from 'discord-player-music';\r\nimport { Client, EmbedBuilder, GatewayIntentBits, Partials, TextChannel, VoiceChannel } from 'discord.js';\r\n\r\nimport { Filter, LyricsData, PlayerQueue } from 'discord-player-music/types/PlayerData';\r\n\r\nconst client = new Client({\r\n    intents: [\r\n        GatewayIntentBits.Guilds,\r\n        GatewayIntentBits.GuildMembers,\r\n        GatewayIntentBits.GuildMessageReactions,\r\n        GatewayIntentBits.GuildMessages,\r\n        GatewayIntentBits.GuildVoiceStates,\r\n        GatewayIntentBits.MessageContent\r\n    ],\r\n\r\n    partials: [\r\n        Partials.Channel,\r\n        Partials.GuildMember,\r\n        Partials.Message,\r\n        Partials.Reaction,\r\n        Partials.User\r\n    ]\r\n})\r\n\r\nconst defaultPrefix = '!';\r\nconst player = new Player(client);\r\n\r\nclient.on('ready', async () => {\r\n    return console.log(`${client.user?.tag} is ready!`);\r\n})\r\n\r\nclient.login('YOUR_CLIENT_TOKEN_HERE');\r\n```\r\n\r\n## Bot command initialization\r\n```js\r\nclient.on('messageCreate', async message => {\r\n    const msgChannel = message.channel as TextChannel;\r\n    const messageArray = message.content.split(' ');\r\n    const command = messageArray[0];\r\n})\r\n```\r\n\r\n## Writing bot commands\r\n\r\n### Search command\r\n```js\r\nif(command === `${defaultPrefix}search`) {\r\n    const searchQuery = message.content.substring(defaultPrefix.length + 7);\r\n\r\n    if(!message.member?.voice.channel) {\r\n        message.channel.send({ content: `${message.member}, join to the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    if(!searchQuery) {\r\n        message.channel.send({ content: `${message.member}, enter your search query!` });\r\n        return;\r\n    }\r\n        \r\n    const searchData = await player.search(searchQuery, message.member, msgChannel);\r\n        \r\n    if(searchData?.error) {\r\n        console.log(searchData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else{\r\n        if(searchData[0].searchType.includes(Search.TITLE)) {\r\n            const embed = new EmbedBuilder()\r\n                \r\n            .setColor('Blue')\r\n            .setTitle('Select track:')\r\n            .setThumbnail(client.user?.avatarURL() as string)\r\n            .setDescription(searchData.map((track, index) => `\\`[${index + 1}]\\` **[${track.title}](${track.url})** \\`[${track.duration.hours}:${track.duration.minutes}:${track.duration.seconds}]\\``).join('\\n'))\r\n\r\n            const msg = await message.channel.send({ embeds: [embed] });\r\n\r\n            player.createCollector(Collector.REACTION, msg, searchData, message.author.id);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Lyrics command\r\n```js\r\nif(command === `${defaultPrefix}lyrics`) {\r\n    const searchQuery = message.content.substring(defaultPrefix.length + 7);\r\n\r\n    if(!searchQuery) {\r\n        message.channel.send({ content: `${message.member}, enter your search query!` });\r\n        return;\r\n    }\r\n\r\n    const searchData = await player.lyrics(searchQuery);\r\n\r\n    if(searchData?.error) {\r\n        console.log(searchData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else{\r\n        const lyricsData = searchData as LyricsData;\r\n\r\n        if((lyricsData.result.length + lyricsData.query.length) <= 2048) message.channel.send({ content: `Search Query: **${lyricsData.query}**\\n\\n${lyricsData.result}` })\r\n        else message.channel.send({ content: `${message.member}, result content exceeds 2048 characters!` });\r\n    }\r\n}\r\n```\r\n\r\n### Queue command\r\n\r\n```js\r\nif(command === `${defaultPrefix}queue`) {\r\n    const guildQueue = await player.queue.get(msgChannel.guild.id);\r\n\r\n    if(guildQueue?.error) {\r\n        console.log(guildQueue.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else{\r\n        const queue = guildQueue as PlayerQueue;\r\n\r\n        const embed = new EmbedBuilder()\r\n\r\n        .setColor('Blue')\r\n        .setTitle(`Guild Queue: ${queue.tracks.length}`)\r\n        .setThumbnail(client.user?.avatarURL() as string)\r\n        .setDescription(queue.tracks.map((track, index) => `\\`[${index + 1}]\\` **[${track.title}](${track.url})** \\`[${track.duration.hours}:${track.duration.minutes}:${track.duration.seconds}]\\``).join('\\n'))\r\n\r\n        message.channel.send({ embeds: [embed] });\r\n    }\r\n}\r\n```\r\n\r\n### Stop command\r\n\r\n```js\r\nif(command === `${defaultPrefix}stop`) {\r\n    if(!message.member?.voice.channel) {\r\n        message.channel.send({ content: `${message.member}, join to the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    const stopData = await player.queue.stop(msgChannel.guild.id);\r\n\r\n    if(stopData?.error) {\r\n        console.log(stopData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else message.channel.send({ content: `${message.member}, server queue playing completed successfully!` });\r\n}\r\n```\r\n\r\n### Skip command\r\n\r\n```js\r\nif(command === `${defaultPrefix}skip`) {\r\n    if(!message.member?.voice.channel) {\r\n        message.channel.send({ content: `${message.member}, join to the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    const skipData = await player.queue.skipTrack(msgChannel.guild.id);\r\n\r\n    if(skipData?.error) {\r\n        console.log(skipData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else{\r\n        if(skipData.next != null) message.channel.send({ content: `Skip track '${skipData.current.title}' and start playing '${skipData.next.title}'!` });\r\n        else message.channel.send({ content: `Skip track '${skipData.current.title}'!` });\r\n    }\r\n}\r\n```\r\n\r\n### Seek command\r\n\r\n```js\r\nif(command === `${defaultPrefix}seek`) {\r\n    const seekValue = Number(message.content.substring(defaultPrefix.length + 5));\r\n        \r\n    if(!message.member?.voice.channel) {\r\n        message.channel.send({ content: `${message.member}, join to the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    if(seekValue && isNaN(seekValue)) {\r\n        message.channel.send({ content: `` });\r\n        return;\r\n    }\r\n        \r\n    const seekData = await player.queue.seek(msgChannel.guild.id, seekValue || 0);\r\n\r\n    if(seekData?.error) {\r\n        console.log(seekData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else message.channel.send({ content: `The current track has been successfully rewound by ${seekValue} seconds!` });\r\n}\r\n```\r\n\r\n### Filter command\r\n\r\n```js\r\nif(command === `${defaultPrefix}filter`) {\r\n    const filter = message.content.substring(defaultPrefix.length + 7) as Filter;\r\n\r\n    if(!message.member?.voice.channel) {\r\n        message.channel.send({ content: `${message.member}, join to the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    if(filter && !await player.filters.isExists(filter)) {\r\n        message.channel.send({ content: `${message.member}, you have specified an unknown filter!` });\r\n    }else{\r\n        const filterData = await player.queue.setFilter(msgChannel.guild.id, filter || 'clear');\r\n\r\n        if(filterData?.error) {\r\n            console.log(filterData.error);\r\n\r\n            message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n        }else message.channel.send({ content: `Playback filter **${filterData.name}** installed successfully!` });\r\n    }\r\n}\r\n```\r\n\r\n### Join command\r\n\r\n```js\r\nif(command === `${defaultPrefix}join`) {\r\n    const channelName = message.content.substring(defaultPrefix.length + 5);\r\n\r\n    if(!channelName) {\r\n        message.channel.send({ content: `${message.member}, enter the name of the voice channel!` });\r\n        return;\r\n    }\r\n\r\n    const channel = message.guild?.channels.cache.find(c => c.name === channelName);\r\n\r\n    if(channel && channel.isVoiceBased()) {\r\n        const joinData = await player.voice.join(channel as VoiceChannel);\r\n\r\n        if(joinData?.error) {\r\n            console.log(joinData.error);\r\n\r\n            message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n        }else message.channel.send({ content: `Member, the bot has successfully joined the ${channel} channel!` });\r\n    }\r\n}\r\n```\r\n\r\n### Leave command\r\n\r\n```js\r\nif(command === `${defaultPrefix}leave`) {\r\n    const leaveData = await player.voice.leave(msgChannel.guild.id);\r\n\r\n    if(leaveData?.error) {\r\n        console.log(leaveData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else message.channel.send({ content: `${message.member}, the bot has successfully left the ${message.guild?.channels.cache.get(leaveData.joinConfig.channelId as string)} voice channel!` });\r\n}\r\n```\r\n\r\n### Nowplaying command\r\n\r\n```js\r\nif(command === `${defaultPrefix}nowplaying`) {\r\n    const trackData = await player.queue.trackInfo(msgChannel.guild.id);\r\n\r\n    if(trackData?.error) {\r\n        console.log(trackData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else{\r\n        const progressData = await player.queue.progress(msgChannel.guild.id);\r\n\r\n        message.channel.send({ content: `Track Title: **${trackData.title}**\\nTrack URL: **${trackData.url}**\\nTrack Duration: **[${trackData.duration.hours}:${trackData.duration.minutes}:${trackData.duration.seconds}]**\\n\\nProgress: [${progressData.percents}] ${progressData.bar}` });\r\n    }\r\n}\r\n```\r\n\r\n### Loop command\r\n\r\n```js\r\nif(command === `${defaultPrefix}loop`) {\r\n    const type = message.content.substring(defaultPrefix.length + 5);\r\n\r\n    if(type) {\r\n        if(!type.includes('track') && !type.includes('queue')) {\r\n            message.channel.send({ content: `${message.member}, you specified an incorrect loop type!` });\r\n        }else{\r\n            const loopData = await player.queue.setLoop(msgChannel.guild.id, type.includes('track') ? Loop.TRACK : Loop.QUEUE);\r\n\r\n            if(loopData?.error) {\r\n                console.log(loopData.error);\r\n\r\n                message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n            }else message.channel.send({ content: `${message.member}, looping status changed successfully!` });\r\n        }\r\n    }else{\r\n        const loopData = await player.queue.setLoop(msgChannel.guild.id, Loop.TRACK);\r\n\r\n        if(loopData?.error) {\r\n            console.log(loopData.error);\r\n\r\n            message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n        }else message.channel.send({ content: `${message.member}, looping status changed successfully!` });\r\n    }\r\n}\r\n```\r\n\r\n### Pause command\r\n\r\n```js\r\nif(command === `${defaultPrefix}pause`) {\r\n    const setStateData = await player.queue.setState(message.guild?.id as string, GuildQueueState.PAUSED);\r\n\r\n    if(setStateData?.error) {\r\n        console.log(setStateData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else message.channel.send({ content: `${message.member}, queue playback successfully paused!` });\r\n}\r\n```\r\n\r\n### Resume command\r\n\r\n```js\r\nif(command === `${defaultPrefix}resume`) {\r\n    const setStateData = await player.queue.setState(message.guild?.id as string, GuildQueueState.PLAYING);\r\n\r\n    if(setStateData?.error) {\r\n        console.log(setStateData.error);\r\n\r\n        message.channel.send({ content: `${message.member}, an error occurred while executing the command, take a look at the console!` });\r\n    }else message.channel.send({ content: `${message.member}, queue playback successfully resumed!` });\r\n}\r\n```\r\n\r\n## Player Events Handling\r\n\r\n### Ready event\r\n\r\n```js\r\nplayer.on('ready', async () => {\r\n    return console.log(`\\nPlayer by ${player.author} is ready!\\nCurrent package version: ${player.version}\\nPackage website URL: ${player.website}`);\r\n})\r\n```\r\n\r\n### Error event\r\n\r\n```js\r\nplayer.on('error', async errorData => {\r\n    return console.log(errorData);\r\n})\r\n```\r\n\r\n### QueueStarted event\r\n\r\n```js\r\nplayer.on('queueStarted', async queue => {\r\n    const channel = queue.channel.text;\r\n\r\n    return channel.send({ content: `Queue for server with ID '${channel.guild.id}' started!` });\r\n})\r\n```\r\n\r\n### CreatedPlaylist event\r\n\r\n```js\r\nplayer.on('createdPlaylist', async playlist => {\r\n    return console.log(`Playlist with id ${playlist.id} success created!`);\r\n})\r\n```\r\n\r\n### DeletedPlaylist event\r\n\r\n```js\r\nplayer.on('deletedPlaylist', async playlist => {\r\n    return console.log(`Playlist with id ${playlist.id} successfully deleted!`);\r\n})\r\n```\r\n\r\n### PlayingTrack event\r\n\r\n```js\r\nplayer.on('playingTrack', async track => {\r\n    const channel = track.channel.text;\r\n\r\n    return channel.send({ content: `Playing '${track.title}' track...` });\r\n})\r\n```\r\n\r\n### AddedTrack event\r\n\r\n```js\r\nplayer.on('addedTrack', async track => {\r\n    const channel = track.channel.text;\r\n\r\n    return channel.send({ content: `Track '${track.title}' added to queue...` });\r\n})\r\n```\r\n\r\n### QueueEnded event\r\n\r\n```js\r\nplayer.on('queueEnded', async queue => {\r\n    const channel = queue.channel.text;\r\n\r\n    return channel.send({ content: `Queue for server with ID '${channel.guild.id}' ended!` });\r\n})\r\n```\r\n\r\n### QueueStateChange event\r\n\r\n```js\r\nplayer.on('queueStateChange', (queue, oldState, newState) => {\r\n    const channel = queue.channel.text;\r\n\r\n    channel.send({ content: `Queue state changed with '${oldState}' on '${newState}'!` });\r\n})\r\n```",
     "path": "docs/general/examples/index.md"
    },
    "changelog": {
     "name": "Changelog",
     "type": "md",
     "content": "# Module Changelog\r\n* ***Version 1.0.0***\r\n  * Release module\r\n* ***Version 1.0.1***\r\n  * Code optimization\r\n  * Fix methods `joinVoiceChannel()` and `leaveVoiceChannel()`\r\n  * Added the `formatNumbers()` method for formatting numbers\r\n  * Fix bugs\r\n  * Fix `README.md`\r\n* ***Version 1.0.2***\r\n  * Code optimization\r\n  * Fixed bug with repeating song/queue\r\n  * Improving the quality of playing songs\r\n  * Added filter system. Method `setFilter()`\r\n  * Changing the returned data by some methods and events\r\n  * Added the `getGuildMap()` method to get the server queue object\r\n* ***Version 1.0.3***\r\n  * Code optimization\r\n  * Fix caught some bugs\r\n  * Fixed minor bugs\r\n  * Rewrite `README.md`\r\n  * Fixed events\r\n* ***Versions 1.0.4 - 1.0.5***\r\n  * Update versions all dependencies\r\n  * Fix `README.md`\r\n* ***Version 1.0.6***\r\n  * Fix module typings\r\n  * Fix minor bugs\r\n  * Added the `getFilters()` method to get arrays with player filters\r\n  * Fix `README.md`\r\n* ***Version 1.0.7***\r\n  * Update versions all dependencies\r\n* ***Version 1.0.8***\r\n  * Fix method `searchVideo()`\r\n  * Added the `getLyrics()` method to get lyrics for current song\r\n* ***Version 1.1.0***\r\n  * Fix filter system\r\n  * Added the `shuffle()` method for shuffling songs in queue\r\n* ***Version 1.1.1***\r\n  * The `playerError` event has started to catch more errors about which users can be warned\r\n  * When receiving an error `Status code: 403`, the module will restart the stream (previously, the stream simply ended)\r\n  * Add the `removeSong()` method for removing songs from the queue\r\n  * Completely rewritten `README.md`\r\n  * Release of module documentation. Link: [dpm-docs](https://dpm-docs.tk)\r\n* ***Version 1.1.2***\r\n  * Updating the documentation for the new design style\r\n  * The module structure has been completely rewritten\r\n  * Added class `Utils`, some methods have been moved to it and marked as `public`\r\n* ***Version 1.1.3***\r\n  * Remove dependency on `<Discord.Message>` completely\r\n  * The `searchVideo()` method has been replaced with `searchSong()`\r\n  * Completely rewritten TypeScript code\r\n  * The `getSongIndex()` and `addSong()` methods have been changed\r\n  * The `playerError` event have been changed\r\n* ***Version 1.1.5***\r\n  * The module structure has been completely rewritten on managers\r\n  * Completely rewritten `README.md`\r\n  * Rewritten TypeScript code\r\n  * Correction of bugs and errors\r\n  * Adding support for `discord.js v13`\r\n  * and many other changes...\r\n* ***Version 1.1.6***\r\n  * Fix Voice Manager\r\n* ***Version 1.1.7***\r\n  * The module has been completely rewritten to the new structure and the TypeScript language\r\n  * Replaced old domain [dpm-docs](https://dpm-docs.tk) with new one [dpm-website](https://dpm.js.org)\r\n  * Added new managers, simplified work with old ones\r\n  * Optimization of module algorithms\r\n  * Added server playlist functionality\r\n  * Removed support for `discord.js v12` and added support for the current `discord.js v14`\r\n  * Updated dependency versions to the latest ones\r\n  * Updated old and added new events\r\n  * Partial transition to enumerated types (enum)\r\n  * The rest of the changes can be seen more clearly on the updates page...",
     "path": "docs/general/changelog.md"
    }
   }
  }
 },
 "classes": [
  {
   "name": "Player",
   "description": "Class representing a Player.",
   "extends": [
    [
     [
      "PlayerEmitter",
      "<"
     ],
     [
      "PlayerEvents",
      ">"
     ]
    ]
   ],
   "construct": {
    "name": "Player",
    "description": "Creates a new instance of the Player.",
    "params": [
     {
      "name": "client",
      "description": "The client instance associated with the player.",
      "type": [
       [
        [
         "Client"
        ]
       ]
      ]
     },
     {
      "name": "options",
      "description": "Optional player options.",
      "optional": true,
      "type": [
       [
        [
         "PlayerOptions"
        ]
       ]
      ]
     }
    ]
   },
   "props": [
    {
     "name": "utils",
     "description": "Player Utils",
     "type": [
      [
       [
        "PlayerUtils"
       ]
      ]
     ],
     "meta": {
      "line": 56,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "options",
     "description": "Player Options",
     "type": [
      [
       [
        "PlayerOptions"
       ]
      ]
     ],
     "meta": {
      "line": 63,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "readyTimestamp",
     "description": "Player Ready Timestamp",
     "type": [
      [
       [
        "number"
       ]
      ]
     ],
     "meta": {
      "line": 70,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "voice",
     "description": "Player Voice Manager",
     "type": [
      [
       [
        "VoiceManager"
       ]
      ]
     ],
     "meta": {
      "line": 77,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "isReady",
     "description": "Player Ready State",
     "type": [
      [
       [
        "boolean"
       ]
      ]
     ],
     "meta": {
      "line": 87,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "developer",
     "description": "Player Developer",
     "type": [
      [
       [
        "string"
       ]
      ]
     ],
     "meta": {
      "line": 96,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "docs",
     "description": "Player Documentation URL",
     "type": [
      [
       [
        "string"
       ]
      ]
     ],
     "meta": {
      "line": 105,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "version",
     "description": "Player Version",
     "type": [
      [
       [
        "string"
       ]
      ]
     ],
     "meta": {
      "line": 114,
      "file": "index.ts",
      "path": ""
     }
    }
   ],
   "methods": [
    {
     "name": "init",
     "description": "Initializes the package.",
     "access": "private",
     "returns": [
      [
       [
        "void"
       ]
      ]
     ],
     "meta": {
      "line": 123,
      "file": "index.ts",
      "path": ""
     }
    }
   ],
   "events": [
    {
     "name": "ready",
     "description": "Event triggered when the player is ready.",
     "params": [
      {
       "name": "player",
       "description": "The Player instance associated with the ready event.",
       "type": [
        [
         [
          "Player"
         ]
        ]
       ]
      }
     ],
     "meta": {
      "line": 205,
      "file": "index.ts",
      "path": ""
     }
    },
    {
     "name": "error",
     "description": "Event triggered when an error occurs.",
     "params": [
      {
       "name": "error",
       "description": "The error object associated with the error event.",
       "type": [
        [
         [
          "PlayerError"
         ]
        ]
       ]
      }
     ],
     "meta": {
      "line": 213,
      "file": "index.ts",
      "path": ""
     }
    }
   ],
   "meta": {
    "line": 19,
    "file": "index.ts",
    "path": ""
   }
  },
  {
   "name": "PlayerEmitter",
   "description": "Represents an event emitter for player events.",
   "access": "private",
   "methods": [
    {
     "name": "on",
     "description": "Registers an event listener for the specified event.",
     "params": [
      {
       "name": "event",
       "description": "The event to listen for.",
       "type": [
        [
         [
          "PlayerEvents"
         ]
        ]
       ]
      },
      {
       "name": "listener",
       "description": "The listener function to be called when the event occurs.",
       "type": [
        [
         [
          "function"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "PlayerEmitter"
        ]
       ]
      ],
      "description": "The current PlayerEmitter instance for method chaining."
     },
     "meta": {
      "line": 14,
      "file": "Emitter.ts",
      "path": "src"
     }
    },
    {
     "name": "once",
     "description": "Registers a one-time event listener for the specified event.\rThe listener will be automatically removed after being called once.",
     "params": [
      {
       "name": "event",
       "description": "The event to listen for.",
       "type": [
        [
         [
          "PlayerEvents"
         ]
        ]
       ]
      },
      {
       "name": "listener",
       "description": "The listener function to be called when the event occurs.",
       "type": [
        [
         [
          "function"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "PlayerEmitter"
        ]
       ]
      ],
      "description": "The current PlayerEmitter instance for method chaining."
     },
     "meta": {
      "line": 28,
      "file": "Emitter.ts",
      "path": "src"
     }
    },
    {
     "name": "emit",
     "description": "Emits the specified event and passes all parameters to the listener.",
     "params": [
      {
       "name": "event",
       "description": "The event to emit.",
       "type": [
        [
         [
          "PlayerEvents"
         ]
        ]
       ]
      },
      {
       "name": "args",
       "description": "The arguments to pass to the listeners.",
       "variable": true,
       "type": [
        [
         [
          "any"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "boolean"
        ]
       ]
      ],
      "description": "A flag indicating whether the event had listeners or not."
     },
     "meta": {
      "line": 43,
      "file": "Emitter.ts",
      "path": "src"
     }
    }
   ],
   "meta": {
    "line": 3,
    "file": "Emitter.ts",
    "path": "src"
   }
  },
  {
   "name": "PlayerError",
   "description": "Custom error class for player-related errors.",
   "extends": [
    [
     [
      "Error"
     ]
    ]
   ],
   "access": "private",
   "construct": {
    "name": "PlayerError",
    "description": "Constructs a new instance of PlayerError.",
    "params": [
     {
      "name": "error",
      "description": "The error message.",
      "type": [
       [
        [
         "string"
        ]
       ]
      ]
     }
    ]
   },
   "meta": {
    "line": 1,
    "file": "Error.ts",
    "path": "src"
   }
  },
  {
   "name": "VoiceManager",
   "description": "Class representing a Player Voice Manager.",
   "methods": [
    {
     "name": "isConnected",
     "description": "Checks if the bot is connected to a voice channel in the specified guild.",
     "params": [
      {
       "name": "guild",
       "description": "The guild to check.",
       "type": [
        [
         [
          "Guild"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "boolean"
        ]
       ]
      ],
      "description": "Returns true if the bot is connected to a voice channel in the guild, otherwise false."
     },
     "meta": {
      "line": 15,
      "file": "VoiceManager.ts",
      "path": "src/managers"
     }
    },
    {
     "name": "join",
     "description": "Joins a voice channel.",
     "params": [
      {
       "name": "channel",
       "description": "The voice channel to join.",
       "nullable": true,
       "type": [
        [
         [
          "VoiceChannel"
         ]
        ],
        [
         [
          "StageChannel"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "Promise",
         "<"
        ],
        [
         "VoiceConnection",
         ">"
        ]
       ]
      ],
      "description": "A Promise that resolves to the VoiceConnection instance."
     },
     "meta": {
      "line": 30,
      "file": "VoiceManager.ts",
      "path": "src/managers"
     }
    },
    {
     "name": "leave",
     "description": "Leaves the voice channel.",
     "params": [
      {
       "name": "channel",
       "description": "The voice channel to leave.",
       "nullable": true,
       "type": [
        [
         [
          "VoiceChannel"
         ]
        ],
        [
         [
          "StageChannel"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "Promise",
         "<"
        ],
        [
         "void",
         ">"
        ]
       ]
      ],
      "description": "A Promise that resolves when the voice channel is left."
     },
     "meta": {
      "line": 61,
      "file": "VoiceManager.ts",
      "path": "src/managers"
     }
    }
   ],
   "meta": {
    "line": 8,
    "file": "VoiceManager.ts",
    "path": "src/managers"
   }
  },
  {
   "name": "PlayerUtils",
   "description": "Utility class for Player-related operations.",
   "methods": [
    {
     "name": "checkOptions",
     "description": "Checks and updates the player options.",
     "params": [
      {
       "name": "options",
       "description": "The player options to be checked and updated.",
       "optional": true,
       "type": [
        [
         [
          "PlayerOptions"
         ]
        ]
       ]
      }
     ],
     "returns": {
      "types": [
       [
        [
         "PlayerOptions"
        ]
       ]
      ],
      "description": "The updated player options."
     },
     "meta": {
      "line": 11,
      "file": "Utils.ts",
      "path": "src"
     }
    }
   ],
   "meta": {
    "line": 4,
    "file": "Utils.ts",
    "path": "src"
   }
  }
 ],
 "interfaces": [],
 "typedefs": [
  {
   "name": "PlayerOptions",
   "description": "Represents options for the Player.",
   "type": [
    [
     [
      "object"
     ]
    ]
   ],
   "props": [
    {
     "name": "addTracksToQueue",
     "description": "Determines whether to add tracks to the queue.",
     "optional": true,
     "default": true,
     "type": [
      [
       [
        "boolean"
       ]
      ]
     ]
    },
    {
     "name": "searchResultsCount",
     "description": "The number of search results.",
     "optional": true,
     "default": 10,
     "type": [
      [
       [
        "number"
       ]
      ]
     ]
    },
    {
     "name": "synchronLoop",
     "description": "Determines whether to enable synchronous looping.",
     "optional": true,
     "default": true,
     "type": [
      [
       [
        "boolean"
       ]
      ]
     ]
    },
    {
     "name": "defaultVolume",
     "description": "The default volume level.",
     "optional": true,
     "default": 5,
     "type": [
      [
       [
        "number"
       ]
      ]
     ]
    },
    {
     "name": "configs",
     "description": "Additional player configurations.",
     "optional": true,
     "type": [
      [
       [
        "PlayerConfigs"
       ]
      ]
     ]
    }
   ],
   "meta": {
    "line": 149,
    "file": "index.ts",
    "path": ""
   }
  },
  {
   "name": "PlayerConfigs",
   "description": "Represents additional configurations for the Player.",
   "type": [
    [
     [
      "object"
     ]
    ]
   ],
   "props": [
    {
     "name": "progressBar",
     "description": "Configuration for the progress bar.",
     "optional": true,
     "type": [
      [
       [
        "PlayerProgressBarConfig"
       ]
      ]
     ]
    },
    {
     "name": "collectors",
     "description": "Configuration for the collectors.",
     "optional": true,
     "type": [
      [
       [
        "PlayerCollectorsConfig"
       ]
      ]
     ]
    }
   ],
   "meta": {
    "line": 161,
    "file": "index.ts",
    "path": ""
   }
  },
  {
   "name": "PlayerProgressBarConfig",
   "description": "Represents the configuration for the progress bar of the Player.",
   "type": [
    [
     [
      "object"
     ]
    ]
   ],
   "props": [
    {
     "name": "size",
     "description": "The size of the progress bar.",
     "optional": true,
     "default": 11,
     "type": [
      [
       [
        "number"
       ]
      ]
     ]
    },
    {
     "name": "line",
     "description": "The style of the progress bar line.",
     "optional": true,
     "default": "â–¬",
     "type": [
      [
       [
        "string"
       ]
      ]
     ]
    },
    {
     "name": "slider",
     "description": "The style of the progress bar slider.",
     "optional": true,
     "default": "ðŸ”˜",
     "type": [
      [
       [
        "string"
       ]
      ]
     ]
    }
   ],
   "meta": {
    "line": 170,
    "file": "index.ts",
    "path": ""
   }
  },
  {
   "name": "PlayerCollectorsConfig",
   "description": "Represents the configuration for the collectors of the Player.",
   "type": [
    [
     [
      "object"
     ]
    ]
   ],
   "props": [
    {
     "name": "message",
     "description": "Configuration for message collectors.",
     "optional": true,
     "type": [
      [
       [
        "object"
       ]
      ]
     ]
    },
    {
     "name": "message.time",
     "description": "The time duration for message collectors.",
     "optional": true,
     "default": "30s",
     "type": [
      [
       [
        "string"
       ]
      ]
     ]
    },
    {
     "name": "message.attempts",
     "description": "The number of attempts for message collectors.",
     "optional": true,
     "default": 1,
     "type": [
      [
       [
        "number"
       ]
      ]
     ]
    },
    {
     "name": "reaction",
     "description": "Configuration for reaction collectors.",
     "optional": true,
     "type": [
      [
       [
        "object"
       ]
      ]
     ]
    },
    {
     "name": "reaction.time",
     "description": "The time duration for reaction collectors.",
     "optional": true,
     "default": "30s",
     "type": [
      [
       [
        "string"
       ]
      ]
     ]
    },
    {
     "name": "reaction.attempts",
     "description": "The number of attempts for reaction collectors.",
     "optional": true,
     "default": 1,
     "type": [
      [
       [
        "number"
       ]
      ]
     ]
    },
    {
     "name": "reaction.reactions",
     "description": "The allowed reactions for reaction collectors.",
     "optional": true,
     "type": [
      [
       [
        "Array",
        "<"
       ],
       [
        "string",
        ">"
       ]
      ]
     ]
    }
   ],
   "meta": {
    "line": 180,
    "file": "index.ts",
    "path": ""
   }
  },
  {
   "name": "PlayerEvents",
   "description": "Represents the events for the Player.",
   "type": [
    [
     [
      "object"
     ]
    ]
   ],
   "props": [
    {
     "name": "ready",
     "description": "Event triggered when the player is ready.",
     "type": [
      [
       [
        "function"
       ]
      ]
     ]
    },
    {
     "name": "error",
     "description": "Event triggered when an error occurs.",
     "type": [
      [
       [
        "function"
       ]
      ]
     ]
    }
   ],
   "meta": {
    "line": 196,
    "file": "index.ts",
    "path": ""
   }
  }
 ],
 "externals": []
}